---
title: "BCB420 Assignment 1- Data set selection and initial processing"
author: "Angela Ng"
output: 
  html_document:
    toc: true
    toc_depth: 2
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

# Introduction

## Download the data

Firstly, we need to download the dataset containing the counts from GEO.  We 
want to do it so that it is only downloaded once initially.

```{r, message=FALSE, warning=FALSE}
# Install required packages 
if (!requireNamespace("BiocManager", quietly = TRUE)) {
  install.packages("BiocManager")
}
if (!requireNamespace("GEOquery", quietly = TRUE)) {
  BiocManager::install("GEOquery")
}
if (!requireNamespace("biomart", quietly = TRUE)) {
  BiocManager::install("biomaRt")
}
if (!requireNamespace("ggplot2", quietly = TRUE)) {
  install.packages("ggplot2")
}
if (!requireNamespace("tibble", quietly = TRUE)) {
  install.packages("tibble")
}
if (!requireNamespace("dplyr", quietly = TRUE)) {
  install.packages("dplyr")
} 
if (!requireNamespace("ggpubr", quietly = TRUE)) {
  install.packages("ggpubr")
}
if (!requireNamespace("edgeR", quietly = TRUE)) {
  install.packages("edgeR")
}
if (!requireNamespace("gridExtra", quietly = TRUE)) {
  install.packages("gridExtra")
}
if (!requireNamespace("limma", quietly = TRUE)) {
  install.packages("limma")
}
suppressPackageStartupMessages({
  library("biomaRt")
  library("ggplot2")
  library("tibble")
  library("dplyr")
  library("edgeR")
})
gse <- "GSE116250"
gseDirectory <- "/home/rstudio/projects/GSE116250"
if (!file.exists(gseDirectory)) {
  # Get supplementary files from GEO
  suppFiles <- GEOquery::getGEOSuppFiles(gse)
  fileName <- rownames(suppFiles)[[1]]
} else {
  fileName <- paste(gseDirectory, "GSE116250_rpkm.txt.gz", sep = "/")
}
```
There is only one file from the data set downloaded from GEO.  This is the 
`GSE116250_rpkm.txt.gz`.  We can now read in the file

```{r, tidy=TRUE}
expData <- read.delim(fileName, header = TRUE, check.names = FALSE)
expData <- tibble::as_tibble(expData)
head(expData)
```

# Exploratory analysis

First, let's see how many genes we have measurements for
```{r}
dim(expData)
colnames(expData)
```

From this we see there are 57974 rows and 66 columns in this data set.  The rows
correspond to genes and the columns correspond to the different samples.  There
are 37 samples from dilated cardiomyopathy (DCM), 13 samples from ischemic 
cardiomyopathy (ICM), and 14 non-failing heards (NF).  In total there are 64 samples.

Next, let's see see how many instances there are of each gene and if there are 
any duplicates.

```{r}
geneCountSummary <- sort(table(expData$Gene), decreasing = TRUE)
knitr::kable(geneCountSummary[which(geneCountSummary > 1)][1:10], type="html")
```

These duplicates still seem to be genes of interest and not small non-coding 
RNAs for example.  The gene with the most duplicates at 4 duplicates is 
`ENSG00000148357`, the common name is HMCN2 and is predicted to enable calcium
ion binding activity based on results from NCBI.  We will leave these 
duplicates in the data set.

## Map data to HUGO symbols

In the data set there is a column called `Common_name` but to be safe we will compute our own mapping of genes to their HUGO symbols.

```{r, eval=FALSE}
ensembl <- useMart(biomart="ENSEMBL_MART_ENSEMBL", host="grch37.ensembl.org", path="/biomart/martservice", dataset="hsapiens_gene_ensembl")
ensemblDatasets <- biomaRt::listDatasets(ensembl)
ensemblDatasets[grep(ensemblDatasets$dataset, pattern = "sapiens"),]
ensembl <- biomaRt::useDataset("hsapiens_gene_ensembl", mart = ensembl)
                     
# find the human filters we want
biomartHumanFilters <- biomaRt::listFilters(ensembl)
knitr::kable(biomartHumanFilters[
  grep(biomartHumanFilters$name, pattern = "ensembl"), ], format = "html")
```
Let's look at what ensembl ID our data has.
```{r} 
# Checking the prefix
unique(substr(expData$Gene, start = 1, stop = 4))
# Checking if it has version numbers
grep(expData$Gene, pattern = "\\.")
```
This tells us that we should use `ensemble_gene_id`.

The next step is to do the conversion and stash the results to avoid future computations.
```{r}
conversionStash <- "exp_data_id_conversion.rds"
if (file.exists(conversionStash)) {
  expDataIdConversion <- readRDS(conversionStash)
} else {
  expDataIdConversion <- biomaRt::getBM(attributes = c("ensembl_gene_id", "hgnc_symbol"),
                                          filters = c("ensembl_gene_id"),
                                          values = expData$Gene,
                                          mart = ensembl)
  saveRDS(expDataIdConversion, conversionStash)
}
```
Now, we will examine the number of genes we were able to map.
```{r}
numMappedIds <- length(which(expData$Gene %in% expDataIdConversion$ensembl_gene_id))
# compare to the original
numTotalIds <- length(expData$Gene)
numMappedIds
numTotalIds
numTotalIds - numMappedIds

```
The difference between the number of ensembl IDs mapped and the number of genes in the data set are identical.  This means all of the genes were able to be matched with a HUGO identifer successfully.  From this I speculate the authors have done this step similar to how I have done it to achieve the same result. 

The next step to mapping our genes to HUGO identifiers is combining it back with our experiment data.
```{r}
expDataMapped <- dplyr::inner_join(expData, expDataIdConversion, by = c("Gene" = "ensembl_gene_id"))
```
Now, we will examine if there are any missing hgnc identifiers.
```{r}
# let's check if the 'Common_name' column in expData is the same as the HUGO identifiers
dplyr::filter(expDataMapped, is.na(expDataMapped$hgnc_symbol))
```
From this we see there are no missing HUGO identifiers.

## Assessing the quality of our data

The data in this data set is in reads per kilobase million mapped reads (RPKM).  This means the data has been normalized by library size and length of the transcript so within each sample it is comparable.  

The paper uses Cufflinks which accounts for transcript length across samples or conditions, and positional biases in coverage along the transcript.  These are a concern for intra-sample comparisons.

Let's see how correlated the samples are by plotting the log2 of the mean RPKM for each cohort.
```{r}
# get average RPKM in each cohort for each gene
dcm <- dplyr::select(expDataMapped, contains("DCM"))
dcmAvgRpkm <- rowMeans(dcm)
expDataMapped$DCM_avg_RPKM <- dcmAvgRpkm

icm <- dplyr::select(expDataMapped, contains("ICM"))
icmAvgRpkm <- rowMeans(icm)
expDataMapped$ICM_avg_RPKM <- icmAvgRpkm

nf <- dplyr::select(expDataMapped, contains("NF"))
nfAvgRpkm <- rowMeans(nf)
expDataMapped$NF_avg_RPKM <- nfAvgRpkm


avgRpkm <- tibble::tibble(DCM = dcmAvgRpkm, ICM = icmAvgRpkm, NF = nfAvgRpkm)

# ICM vs DCM
corIcmDcmPlot <- ggplot2::ggplot(data = avgRpkm, aes(x = log2(DCM + 1), y = log2(ICM + 1))) +
  ggplot2::geom_point() +
  ggplot2::labs(title = "Log2 mean ICM RPKM vs Log2 mean DCM RPKM",
                x = "log2(mean DCM RPKM + 1)",
                y = "log2(mean ICM RPKM + 1)") +
  ggplot2::geom_smooth(method = "lm", se = FALSE) + 
  ggpubr::stat_regline_equation(label.y = 50, aes(label = after_stat(rr.label)))
corIcmDcmPlot

# DCM vs NF
corDcmNfPlot <- ggplot2::ggplot(data = avgRpkm, aes(x = log2(NF + 1), y = log2(DCM + 1))) +
  ggplot2::geom_point() +
  ggplot2::labs(title = "Log2 mean DCM RPKM vs Log2 mean NF RPKM",
                x = "log2(mean NF RPKM + 1)",
                y = "log2(mean DCM RPKM + 1)") +
  ggplot2::geom_smooth(method = "lm", se = FALSE) + 
  ggpubr::stat_regline_equation(label.y = 50, aes(label = after_stat(rr.label)))
corDcmNfPlot

# ICM vs NF
corIcmNfPlot <- ggplot2::ggplot(data = avgRpkm, aes(x = log2(NF + 1), y = log2(ICM + 1))) + 
  ggplot2::geom_point() +
  ggplot2::labs(title = "Log2 mean ICM RPKM vs Log2 mean NF RPKM",
                x = "log2(mean NF RPKM + 1)",
                y = "log2(mean ICM RPKM + 1)") +
  ggplot2::geom_smooth(method = "lm", se = FALSE)+ 
  ggpubr::stat_regline_equation(label.y = 50, aes(label = after_stat(rr.label)))
corIcmNfPlot

# + 1 to avoid log of 0

# rsq <- function (x, y) cor(x, y) ^ 2
# plot1Rsq <- rsq(log2(expDataMapped$ICM_avg_RPKM + 1), log2(expDataMapped$DCM_avg_RPKM + 1))
# 
# plot1Rsq
```
These plots show there is a relative good correlation of the relative magnitude of gene expression between the different samples from different cohorts with some outliers towards the ends.

Let's make a density plot.  Note the log2 is log2 rpkm + 1 to avoid log of 0
```{r}
# only keep the Gene and columns with RPKM for each sample
expDataGeneRpkm <- dplyr::select(expDataMapped, -c(2, 67, 68, 69, 70)) 
# need to reshape the data so have Gene, Sample, log2_rpkm as columns
pivotedData <- tidyr::pivot_longer(expDataGeneRpkm, cols = !Gene, names_to = "sample", values_to = "rpkm")
# log2 transform the rpkm column
pivotedData$log2_rpkm <- log2(pivotedData$rpkm + 1) # + 1 to avoid log 0

# due to the large number of samples each cohort will have their own graph
pivotedData$cohort <- gsub("[0-9]", "", pivotedData$sample)
nfSamples <- dplyr::filter(pivotedData, pivotedData$cohort == "NF")
dcmSamples <- dplyr::filter(pivotedData, pivotedData$cohort == "DCM")
icmSamples <- dplyr::filter(pivotedData, pivotedData$cohort == "ICM")

nfDensityPlot <- ggplot2::ggplot(nfSamples, aes(x=log2_rpkm, color=sample)) +
  ggplot2::geom_density(key_glyph = draw_key_smooth) + 
  scale_x_continuous(limits = c(-2, 12))
nfDensityPlot

dcmDensityPlot <- ggplot2::ggplot(dcmSamples, aes(x=log2_rpkm, color=sample)) +
  ggplot2::geom_density(key_glyph = draw_key_smooth) + 
  scale_x_continuous(limits = c(-2, 12))
dcmDensityPlot

icmDensityPlot <- ggplot2::ggplot(icmSamples, aes(x=log2_rpkm, color=sample)) +
  ggplot2::geom_density(key_glyph = draw_key_smooth) + 
  scale_x_continuous(limits = c(-2, 12))
icmDensityPlot
```
Next we will do a boxplot to compare the samples.  Similarly, due to the large number of replicates each cohort has their own plot.
```{r}
nfBoxPlot <- ggplot2::ggplot(nfSamples, aes(x=sample, y=log2_rpkm)) +
  ggplot2::geom_boxplot(outlier.colour = "blue") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
nfBoxPlot

dcmBoxPlot <- ggplot2::ggplot(dcmSamples, aes(x=sample, y=log2_rpkm)) +
  ggplot2::geom_boxplot(outlier.colour = "blue") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
dcmBoxPlot

icmBoxPlot <- ggplot2::ggplot(icmSamples, aes(x=sample, y=log2_rpkm)) +
  ggplot2::geom_boxplot(outlier.colour = "blue") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
icmBoxPlot
```

Due to the large number of replicates it is unpractical to do an MA plot for each pair of replicates.

# Normalization
The authors provided the RPKM for this dataset so it has been normalized within samples.  Now we are going to try to normalize via TMM and if the pre-normalization graphs look the same as the post normalization graphs then we know the data has been normalized between samples too.

Note the paper was unclear about whether or not normalization between samples was performed so this is an exploratory analysis.

** should we filter lowly expressed counts too?**

```{r}
# Extract the cohort and sample number from the original data
# use gsub instead so get the column names then sub the numbers for nothing and in another sub the characters with nothing
cohorts <- gsub("[0-9]", "", colnames(expDataMapped)[3:66])
sampleNum <- gsub("[A-Z]", "", colnames(expDataMapped)[3:66])
samples <- data.frame(cohorts, sampleNum)
rownames(samples) <- colnames(expDataMapped)[3:66]

# Create DGEList object
expDataGeneRpkmMatrix <- dplyr::select(expDataMapped, -c(1, 2, 67, 68, 69, 70))
expDataGeneRpkmMatrix <- as.matrix(sapply(expDataGeneRpkmMatrix, as.numeric))
rownames(expDataGeneRpkmMatrix) <- expDataGeneRpkm$Gene
dgeListObj <- edgeR::DGEList(counts = expDataGeneRpkmMatrix, group = samples$cohorts)

# calculate normalization factors
dgeListObj <- edgeR::calcNormFactors(dgeListObj, method = "TMM")

# Need to get length of the genes before can calculate back to RPKM
geneLengthStash <- "exp_data_gene_lengths.rds"
if (file.exists(geneLengthStash)) {
  geneLengths <- readRDS(geneLengthStash)
} else {
  geneLengths <- biomaRt::getBM(attributes = c("ensembl_gene_id", 
                                             "start_position",
                                             "end_position"),
                                          filters = c("ensembl_gene_id"),
                                          values = rownames(expDataGeneRpkmMatrix),
                                          mart = ensembl)

  saveRDS(geneLengths, geneLengthStash)
}
geneLengths$gene_length <- geneLengths$end_position - geneLengths$start_position

normRpkm <- edgeR::rpkm(dgeListObj, gene.length = geneLengths$gene_length)
```

Now let's plot the normalized data
```{r}
genes <- rownames(normRpkm)
normRpkm <- tibble::as.tibble(normRpkm)
normRpkm$Gene <- genes

normPivotedData <- tidyr::pivot_longer(normRpkm, cols = !Gene, names_to = "sample", values_to = "rpkm")
# log2 transform the rpkm column
normPivotedData$log2_rpkm <- log2(normPivotedData$rpkm + 1) # + 1 to avoid log 0

# due to the large number of samples each cohort will have their own graph
normPivotedData$cohort <- gsub("[0-9]", "", normPivotedData$sample)
normNfSamples <- dplyr::filter(normPivotedData, normPivotedData$cohort == "NF")
normDcmSamples <- dplyr::filter(normPivotedData, normPivotedData$cohort == "DCM")
normIcmSamples <- dplyr::filter(normPivotedData, normPivotedData$cohort == "ICM")

normNfDenistyPlot <- ggplot2::ggplot(normNfSamples, aes(x=log2_rpkm, color=sample)) +
  ggplot2::geom_density(key_glyph = draw_key_smooth) + 
  scale_x_continuous(limits = c(-2, 12))
normNfDenistyPlot

normDcmDenistyPlot <-ggplot2::ggplot(normDcmSamples, aes(x=log2_rpkm, color=sample)) +
  ggplot2::geom_density(key_glyph = draw_key_smooth) + 
  scale_x_continuous(limits = c(-2, 12))
normDcmDenistyPlot

normIcmDenistyPlot <- ggplot2::ggplot(normIcmSamples, aes(x=log2_rpkm, color=sample)) +
  ggplot2::geom_density(key_glyph = draw_key_smooth) + 
  scale_x_continuous(limits = c(-2, 12))
normIcmDenistyPlot
```
Now we will do a boxplot to compare as well.

```{r}
normNfBoxPlot <- ggplot2::ggplot(normNfSamples, aes(x=sample, y=log2_rpkm)) +
  ggplot2::geom_boxplot(outlier.colour = "blue") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
normNfBoxPlot

normDcmBoxPlot <- ggplot2::ggplot(normDcmSamples, aes(x=sample, y=log2_rpkm)) +
  ggplot2::geom_boxplot(outlier.colour = "blue") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
normDcmBoxPlot

normIcmBoxPlot <- ggplot2::ggplot(normIcmSamples, aes(x=sample, y=log2_rpkm)) +
  ggplot2::geom_boxplot(outlier.colour = "blue") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
normIcmBoxPlot
```
Let's compare the data to the pre-normalized and post-normalized form.

```{r}
# Compare the density plots
gridExtra::grid.arrange(nfDensityPlot, normNfDenistyPlot, ncol=2)
gridExtra::grid.arrange(dcmDensityPlot, normDcmDenistyPlot, ncol=2)
gridExtra::grid.arrange(icmDensityPlot, normIcmDenistyPlot, ncol=2)

# Compare the boxplots
gridExtra::grid.arrange(nfBoxPlot, normNfBoxPlot, ncol=2)
gridExtra::grid.arrange(dcmBoxPlot, normDcmBoxPlot, ncol=2)
gridExtra::grid.arrange(icmBoxPlot, normIcmBoxPlot, ncol=2)
```
From this we can see the normalized form keeps the same shape as the original data but the values have changed drastically.  We do not want to modify our data so drastically and in addition in my opinion the density graph no longer makes sense since the normalized data puts all the reads at esentially the same value.

Due to these strange plots after normalization and lack of information in the paper about normalization methods other than RPKM used it is concluded the data posted is already normalized.

## Dispersion

Looking at the dispersion:
```{r}
modelDesign <- model.matrix(~samples$cohorts + samples$sampleNum+0)
dispersion <- edgeR::estimateDisp(dgeListObj)
```

Make a MDS plot
```{r}
limma::plotMDS(dgeListObj, labels=rownames(samples), col = c("darkgreen", "blue")[factor(samples$cohorts)])
```

Plot the BCV plot
```{r}
edgeR::plotBCV(dispersion, col.tagwise = "black", col.common = "red",)
```

## Mean variance plot
```{r}
edgeR::plotMeanVar(dispersion, 
                   show.raw.vars = TRUE,
                   show.tagwise.vars = TRUE,
                   show.ave.raw.vars = TRUE,
                   NBline = TRUE, 
                   show.binned.common.disp.vars = FALSE)
```
** filter the original dataset **
** fix graph titles and sclaes**

Make a PCA plot
```{r}
# if (!requireNamespace("ggfortify", quietly = TRUE)) {
#   install.packages("ggfortify")
# }
# library("ggfortify")
# pcaRes <- prcomp(expDataMapped[, 3:66], scale. = TRUE)
# ggplot2::autoplot(pcaRes, data = expDataMapped, color)
```
# Questions to address

1. What are the control and test conditions of the dataset?
The control of my data set is non-failing hearts (NF).  There are two test conditions which are dilated cardiomyopathy (DCM) and ischemic cardiomyopathy (ICM).

2. Why is the dataset of interest to you?

3. Were there expression values that were not unique for specific genes? How did you handle these?

There were 6 specific genes that were repeated.  I decided to leave them in. 

```{r}
notUnique <- head(geneCountSummary[which(geneCountSummary > 1)])
length(notUnique)
```
4. Were there expression values that could not be mapped to current HUGO symbols?

All expression values were able to be mapped to HUGO symbols.

5. How many outliers were removed?

Based on the box plots there were many outliers for each sample.  

6. How did you handle replicates?

The authors decided to filter out genes in their downstream analysis those with mean RPKM < 5.

Do plot to see where to put rpkm cutoff 
```{r, eval = FALSE}
# try rpkm cutoffs 1 to 10
expDataMapped$all_avg_rpkm <- rowMeans(expDataMapped[, 3:66])
numGenesPastCutoffNf <- c(mode="numeric", length=11) # index corresponds to the cutoff - 1
numGenesPastCutoffDcm <- c(mode="numeric", length=11) # index corresponds to the cutoff - 1
numGenesPastCutoffIcm <- c(mode="numeric", length=11) # index corresponds to the cutoff - 1
for (i in 1:11) {
  # do I do this for each gene
  numGenesPastCutoffNf[i] <- nrow(dplyr::filter(expDataMapped, NF_avg_RPKM >= i - 1))
  numGenesPastCutoffDcm[i] <- nrow(dplyr::filter(expDataMapped, DCM_avg_RPKM >= i - 1))
  numGenesPastCutoffIcm[i] <- nrow(dplyr::filter(expDataMapped, ICM_avg_RPKM >= i - 1))
}

nfPastCutoffs <- tibble::tibble(cohort = "NF", num = as.numeric(numGenesPastCutoffNf), cutoff = c(0:10))
icmPastCutoffs <- tibble::tibble(cohort = "ICM", num = as.numeric(numGenesPastCutoffIcm), cutoff = c(0:10))
dcmPastCutoffs <- tibble::tibble(cohort = "DCM", num = as.numeric(numGenesPastCutoffDcm), cutoff = c(0:10))

numPastCutoffs <- rbind(nfPastCutoffs, icmPastCutoffs, dcmPastCutoffs)


ggplot(numPastCutoffs, aes(x=cutoff, y=num)) +
  geom_line(aes(color = cohort)) +     
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))


```
To examine the distribution of our data we will create a box plot.
The authors filtered their data to mean RPKM greater than or equal to 5 for expressed genes.

```{r, eval=FALSE}
# only keep the Gene and columns with RPKM for each sample
expDataGeneRpkm <- dplyr::select(expDataMapped, -c(2, 67, 68, 69, 70)) 
# need to reshape the data so have Gene, Sample, log2_rpkm as columns
pivotedData <- tidyr::pivot_longer(expDataGeneRpkm, cols = !Gene, names_to = "sample", values_to = "rpkm")
pivotedData <- dplyr::filter(pivotedData, rpkm >= 5)
# log2 transform the rpkm column
pivotedData$log2_rpkm <- log2(pivotedData$rpkm)

# need to do it for each cohort since too many
pivotedData$cohort <- gsub("[0-9]", "", pivotedData$sample)
nfSamples <- dplyr::filter(pivotedData, pivotedData$cohort == "NF")
dcmSamples <- dplyr::filter(pivotedData, pivotedData$cohort == "DCM")
icmSamples <- dplyr::filter(pivotedData, pivotedData$cohort == "ICM")
ggplot(nfSamples, aes(x=sample, y=log2_rpkm), fill = sample) +
  geom_boxplot() + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) 
# + scale_y_continuous(limits = c(0, 40))
ggplot(dcmSamples, aes(x=sample, y=log2_rpkm), fill = sample) +
  geom_boxplot() +     
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
ggplot(icmSamples, aes(x=sample, y=log2_rpkm), fill = sample) +
  geom_boxplot() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) 
# boxplot(as.data.frame(nfSamples[, 3:2]), xlab = "Samples", ylab = "log2 RPKM",
#         las = 2, cex = 0.5, cex.lab = 0.5,
#         cex.axis = 0.5, main = "NF RNASeq Samples")
```
7. What is the final coverage of your dataset?

# References
https://genomebiology.biomedcentral.com/articles/10.1186/s13059-016-0881-8
http://cole-trapnell-lab.github.io/cufflinks/manual/