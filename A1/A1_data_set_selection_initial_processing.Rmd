---
title: "BCB420 Assignment 1- Data set selection and initial processing"
author: "Angela Ng"
output: 
  html_document:
    toc: true
    toc_depth: 2
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

# Introduction

## Download the data

Firstly, we need to download the dataset containing the counts from GEO.  We 
want to do it so that it is only downloaded once initially.

```{r, message=FALSE, warning=FALSE}
# Install required packages 
if (!requireNamespace("BiocManager", quietly = TRUE)) {
  install.packages("BiocManager")
}
if (!requireNamespace("GEOquery", quietly = TRUE)) {
  BiocManager::install("GEOquery")
}
if (!requireNamespace("biomart", quietly = TRUE)) {
  BiocManager::install("biomaRt")
}
if (!requireNamespace("ggplot2", quietly = TRUE)) {
  install.packages("ggplot2")
}
if (!requireNamespace("tibble", quietly = TRUE)) {
  install.packages("tibble")
}
if (!requireNamespace("dplyr", quietly = TRUE)) {
  install.packages("dplyr")
} 
if (!requireNamespace("ggpubr", quietly = TRUE)) {
  install.packages("ggpubr")
}
suppressPackageStartupMessages({
  library("biomaRt")
  library("ggplot2")
  library("tibble")
  library("dplyr")
})
gse <- "GSE116250"
gseDirectory <- "/home/rstudio/projects/GSE116250"
if (!file.exists(gseDirectory)) {
  # Get supplementary files from GEO
  suppFiles <- GEOquery::getGEOSuppFiles(gse)
  fileName <- rownames(suppFiles)[[1]]
} else {
  fileName <- paste(gseDirectory, "GSE116250_rpkm.txt.gz", sep = "/")
}
```
There is only one file from the data set downloaded from GEO.  This is the 
`GSE116250_rpkm.txt.gz`.  We can now read in the file

```{r, tidy=TRUE}
expData <- read.delim(fileName, header = TRUE, check.names = FALSE)
expData <- tibble::as_tibble(expData)
head(expData)
```

# Exploratory analysis

First, let's see how many genes we have measurements for
```{r}
dim(expData)
colnames(expData)
```

From this we see there are 57974 rows and 66 columns in this data set.  The rows
correspond to genes and the columns correspond to the different samples.  There
are 37 samples from dilated cardiomyopathy (DCM), 13 samples from ischemic 
cardiomyopathy (ICM), and 14 non-failing heards (NF).  In total there are 64 samples.

Next, let's see see how many instances there are of each gene and if there are 
any duplicates.

```{r}
geneCountSummary <- sort(table(expData$Gene), decreasing = TRUE)
knitr::kable(geneCountSummary[which(geneCountSummary > 1)][1:10], type="html")
```

These duplicates still seem to be genes of interest and not small non-coding 
RNAs for example.  The gene with the most duplicates at 4 duplicates is 
`ENSG00000148357`, the common name is HMCN2 and is predicted to enable calcium
ion binding activity based on results from NCBI.  We will leave these 
duplicates in the data set.

## Map data to HUGO symbols

In the data set there is a column called `Common_name` but to be safe we will compute our own mapping of genes to their HUGO symbols.

```{r}
ensembl <- useMart(biomart="ENSEMBL_MART_ENSEMBL", host="grch37.ensembl.org", path="/biomart/martservice", dataset="hsapiens_gene_ensembl")
ensemblDatasets <- biomaRt::listDatasets(ensembl)
ensemblDatasets[grep(ensemblDatasets$dataset, pattern = "sapiens"),]
ensembl <- biomaRt::useDataset("hsapiens_gene_ensembl", mart = ensembl)
                     
# find the human filters we want
biomartHumanFilters <- biomaRt::listFilters(ensembl)
knitr::kable(biomartHumanFilters[
  grep(biomartHumanFilters$name, pattern = "ensembl"), ], format = "html")
```
Let's look at what ensembl ID our data has.
```{r} 
# Checking the prefix
unique(substr(expData$Gene, start = 1, stop = 4))
# Checking if it has version numbers
grep(expData$Gene, pattern = "\\.")
```
This tells us that we should use `ensemble_gene_id`.

The next step is to do the conversion and stash the results to avoid future computations.
```{r}
conversionStash <- "exp_data_id_conversion.rds"
if (file.exists(conversionStash)) {
  expDataIdConversion <- readRDS(conversionStash)
} else {
  expDataIdConversion <- biomaRt::getBM(attributes = c("ensembl_gene_id", "hgnc_symbol"),
                                          filters = c("ensembl_gene_id"),
                                          values = expData$Gene,
                                          mart = ensembl)
  saveRDS(expDataIdConversion, conversionStash)
}
```
Now, we will examine the number of genes we were able to map.
```{r}
numMappedIds <- length(which(expData$Gene %in% expDataIdConversion$ensembl_gene_id))
# compare to the original
numTotalIds <- length(expData$Gene)
numMappedIds
numTotalIds
numTotalIds - numMappedIds

```
The difference between the number of ensembl IDs mapped and the number of genes in the data set are identical.  This means all of the genes were able to be matched with a HUGO identifer successfully.  From this I speculate the authors have done this step similar to how I have done it to achieve the same result. 

The next step to mapping our genes to HUGO identifiers is combining it back with our experiment data.
```{r}
expDataMapped <- dplyr::inner_join(expData, expDataIdConversion, by = c("Gene" = "ensembl_gene_id"))
```
Now, we will examine if there are any missing hgnc identifiers.
```{r}
# let's check if the 'Common_name' column in expData is the same as the HUGO identifiers
dplyr::filter(expDataMapped, is.na(expDataMapped$hgnc_symbol))
```
From this we see there are no missing HUGO identifiers.

## Assessing the quality of our data

The data in this data set is in reads per kilobase million mapped reads (RPKM).  This means the data has been normalized by library size and length of the transcript so within each sample it is comparable.  

The paper uses Cufflinks which accounts for transcript length across samples or conditions, and positional biases in coverage along the transcript.  These are a concern for intra-sample comparisons.

Let's see how correlated the samples are by plotting the log2 of the mean RPKM for each cohort.
```{r}
# get average RPKM in each cohort for each gene
dcm <- dplyr::select(expDataMapped, contains("DCM"))
dcmAvgRpkm <- rowMeans(dcm)
expDataMapped$DCM_avg_RPKM <- dcmAvgRpkm

icm <- dplyr::select(expDataMapped, contains("ICM"))
icmAvgRpkm <- rowMeans(icm)
expDataMapped$ICM_avg_RPKM <- icmAvgRpkm

nf <- dplyr::select(expDataMapped, contains("NF"))
nfAvgRpkm <- rowMeans(nf)
expDataMapped$NF_avg_RPKM <- nfAvgRpkm


avgRpkm <- tibble::tibble(DCM = dcmAvgRpkm, ICM = icmAvgRpkm, NF = nfAvgRpkm)

# ICM vs DCM
ggplot2::ggplot(data = avgRpkm, aes(x = log2(DCM + 1), y = log2(ICM + 1))) +
  ggplot2::geom_point() +
  ggplot2::labs(title = "Log2 mean ICM RPKM vs Log2 mean DCM RPKM",
                x = "log2(mean DCM RPKM + 1)",
                y = "log2(mean ICM RPKM + 1)") +
  ggplot2::geom_smooth(method = "lm", se = FALSE) + 
  ggpubr::stat_regline_equation(label.y = 50, aes(label = after_stat(rr.label)))

# DCM vs NF
ggplot2::ggplot(data = avgRpkm, aes(x = log2(NF + 1), y = log2(DCM + 1))) +
  ggplot2::geom_point() +
  ggplot2::labs(title = "Log2 mean DCM RPKM vs Log2 mean NF RPKM",
                x = "log2(mean NF RPKM + 1)",
                y = "log2(mean DCM RPKM + 1)") +
  ggplot2::geom_smooth(method = "lm", se = FALSE) + 
  ggpubr::stat_regline_equation(label.y = 50, aes(label = after_stat(rr.label)))

# ICM vs NF
ggplot2::ggplot(data = avgRpkm, aes(x = log2(NF + 1), y = log2(ICM + 1))) + 
  ggplot2::geom_point() +
  ggplot2::labs(title = "Log2 mean ICM RPKM vs Log2 mean NF RPKM",
                x = "log2(mean NF RPKM + 1)",
                y = "log2(mean ICM RPKM + 1)") +
  ggplot2::geom_smooth(method = "lm", se = FALSE)+ 
  ggpubr::stat_regline_equation(label.y = 50, aes(label = after_stat(rr.label)))

# + 1 to avoid log of 0

rsq <- function (x, y) cor(x, y) ^ 2
plot1Rsq <- rsq(log2(expDataMapped$ICM_avg_RPKM + 1), log2(expDataMapped$DCM_avg_RPKM + 1))

plot1Rsq
```
These plots show there is a relative good correlation of the relative magnitude of gene expression between the different samples from different cohorts with some outliers towards the ends.

Let's make a density plot.  Note the log2 is log2 rpkm + 1 to avoid log of 0
```{r}
# only keep the Gene and columns with RPKM for each sample
filteredData <- dplyr::select(expDataMapped, -c(2, 67, 68, 69, 70)) 
# need to reshape the data so have Gene, Sample, log2_rpkm as columns
pivotedData <- tidyr::pivot_longer(filteredData, cols = !Gene, names_to = "sample", values_to = "rpkm")
# log2 transform the rpkm column
pivotedData$log2_rpkm <- log2(pivotedData$rpkm + 1) # + 1 to avoid log 0

# due to the large number of samples each cohort will have their own graph
pivotedData$cohort <- gsub("[0-9]", "", pivotedData$sample)
nfSamples <- dplyr::filter(pivotedData, pivotedData$cohort == "NF")
dcmSamples <- dplyr::filter(pivotedData, pivotedData$cohort == "DCM")
icmSamples <- dplyr::filter(pivotedData, pivotedData$cohort == "ICM")

ggplot2::ggplot(nfSamples, aes(x=log2_rpkm, color=sample)) +
  ggplot2::geom_density(key_glyph = draw_key_smooth) + 
  scale_x_continuous(limits = c(-2, 12))

ggplot2::ggplot(dcmSamples, aes(x=log2_rpkm, color=sample)) +
  ggplot2::geom_density(key_glyph = draw_key_smooth) + 
  scale_x_continuous(limits = c(-2, 12))

ggplot2::ggplot(icmSamples, aes(x=log2_rpkm, color=sample)) +
  ggplot2::geom_density(key_glyph = draw_key_smooth) + 
  scale_x_continuous(limits = c(-2, 12))

```
Next we will do a boxplot to compare the samples.  Similarly, due to the large number of replicates each cohort has their own plot.
```{r}
ggplot2::ggplot(nfSamples, aes(x=sample, y=log2_rpkm)) +
  ggplot2::geom_boxplot(outlier.colour = "blue") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

ggplot2::ggplot(dcmSamples, aes(x=sample, y=log2_rpkm)) +
  ggplot2::geom_boxplot(outlier.colour = "blue") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

ggplot2::ggplot(icmSamples, aes(x=sample, y=log2_rpkm)) +
  ggplot2::geom_boxplot(outlier.colour = "blue") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```




Do plot to see where to put rpkm cutoff 
```{r}
# try rpkm cutoffs 1 to 10
expDataMapped$all_avg_rpkm <- rowMeans(expDataMapped[, 3:66])
numGenesPastCutoffNf <- c(mode="numeric", length=11) # index corresponds to the cutoff - 1
numGenesPastCutoffDcm <- c(mode="numeric", length=11) # index corresponds to the cutoff - 1
numGenesPastCutoffIcm <- c(mode="numeric", length=11) # index corresponds to the cutoff - 1
for (i in 1:11) {
  # do I do this for each gene
  numGenesPastCutoffNf[i] <- nrow(dplyr::filter(expDataMapped, NF_avg_RPKM >= i - 1))
  numGenesPastCutoffDcm[i] <- nrow(dplyr::filter(expDataMapped, DCM_avg_RPKM >= i - 1))
  numGenesPastCutoffIcm[i] <- nrow(dplyr::filter(expDataMapped, ICM_avg_RPKM >= i - 1))
}

nfPastCutoffs <- tibble::tibble(cohort = "NF", num = as.numeric(numGenesPastCutoffNf), cutoff = c(0:10))
icmPastCutoffs <- tibble::tibble(cohort = "ICM", num = as.numeric(numGenesPastCutoffIcm), cutoff = c(0:10))
dcmPastCutoffs <- tibble::tibble(cohort = "DCM", num = as.numeric(numGenesPastCutoffDcm), cutoff = c(0:10))

numPastCutoffs <- rbind(nfPastCutoffs, icmPastCutoffs, dcmPastCutoffs)


ggplot(numPastCutoffs, aes(x=cutoff, y=num)) +
  geom_line(aes(color = cohort)) +     
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))


```
To examine the distribution of our data we will create a box plot.
The authors filtered their data to mean RPKM greater than or equal to 5 for expressed genes.

```{r}
# only keep the Gene and columns with RPKM for each sample
filteredData <- dplyr::select(expDataMapped, -c(2, 67, 68, 69, 70)) 
# need to reshape the data so have Gene, Sample, log2_rpkm as columns
pivotedData <- tidyr::pivot_longer(filteredData, cols = !Gene, names_to = "sample", values_to = "rpkm")
pivotedData <- dplyr::filter(pivotedData, rpkm >= 5)
# log2 transform the rpkm column
pivotedData$log2_rpkm <- log2(pivotedData$rpkm)

# need to do it for each cohort since too many
pivotedData$cohort <- gsub("[0-9]", "", pivotedData$sample)
nfSamples <- dplyr::filter(pivotedData, pivotedData$cohort == "NF")
dcmSamples <- dplyr::filter(pivotedData, pivotedData$cohort == "DCM")
icmSamples <- dplyr::filter(pivotedData, pivotedData$cohort == "ICM")
ggplot(nfSamples, aes(x=sample, y=log2_rpkm), fill = sample) +
  geom_boxplot() + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) 
# + scale_y_continuous(limits = c(0, 40))
ggplot(dcmSamples, aes(x=sample, y=log2_rpkm), fill = sample) +
  geom_boxplot() +     
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
ggplot(icmSamples, aes(x=sample, y=log2_rpkm), fill = sample) +
  geom_boxplot() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) 
# boxplot(as.data.frame(nfSamples[, 3:2]), xlab = "Samples", ylab = "log2 RPKM",
#         las = 2, cex = 0.5, cex.lab = 0.5,
#         cex.axis = 0.5, main = "NF RNASeq Samples")
```

# Normalization
** filter the original dataset **
** apply TMM **


# Questions to address

1. What are the control and test conditions of the dataset?
2. Why is the dataset of interest to you?
3. Were there expression values that were not unique for specific genes? How did you handle these?
4. Were there expression values that could not be mapped to current HUGO symbols?
5. How many outliers were removed?
6. How did you handle replicates?
7. What is the final coverage of your dataset?

# References
https://genomebiology.biomedcentral.com/articles/10.1186/s13059-016-0881-8
http://cole-trapnell-lab.github.io/cufflinks/manual/